# Bagmatic - a toolkit and CLI for working with BagIt packages #
Much bagit content is subject to various rules, patterns, restrictions, boiler-plate, etc imposed by the producer and/or consumer. Bagmatic exposes a structured model to facilitate the coordination of all these factors to automate and regulate - to the degree possible - creation or evaluation of conforming bags. It can be leveraged as a standalone CLI (command-line tool), or used as a library in a GUI or other (Java) application.

[![Build Status](https://github.com/richardrodgers/bagmatic/actions/workflows/gradle.yml/badge.svg?branch=main)](https://github.com/richardrodgers/bagmatic/actions/workflows/gradle.yml)

## Process Model/Lifecycle ##
Bagmatic starts with the notion of a _Context_, which is a reusable state of configuration. The context consists of: zero or more _constraint sets_, and zero or more _templates_. A context can be used both in the creation of conforming packages and the validation of received packages. In a producer workflow, often multiple bags are transmitted to a single destination abiding by the same configuration, so bagmatic also provides a _Job_, which is a class containing zero of more source specifications, and at least one _delivery_ specification, indicating a destination address and more. One or more related bags can be are _assembled_ using the job state state, using a container of the same name, and transmitted to a _destination_. Let us examine each component in turn.

### Constraints ###
The BagIt specification has very few absolute requirements - only the layout of the directory containing the bag, and a few mandatory files (declaration and manifest). Everything else is optional or configurable, which means that it offers few signposts to help producers and consumers coordinate an information exchange using bags. We can tighten the semantics by imposing mutually understood constraints on how the bag is encoded, what metadata fields are required, etc. Bagmatic offers a language of constraints, which are easily encoded in standard text formats (JSON). Bagmatic will apply one or more sets of constraints to the context, ensuring that any bags produced or evaluated against that context conform to the constraints. It distinguishes between _platform_ constraints (those imposed by the operating system or application environment), and _user_ constraints. Clients of bagmatic will generally not have (modify) access to platform constraints, and they are imposed before any user constraints. This way, a context cannot be configured to a state that is unachievable. One illustration: various low-level libraries used might only support a given version or versions of the BagIt spec, so the platform would impose a constraint that only producible versions be allowed.

For user constraints, bagmatic utilizes the Bagit Profiles Specification (version 1.4 draft 18 at time of writing). See documentation on how to author these JSON specification documents. 

#### Constraint Types ####
There are 3 flavors (or types) of constraints defined. First, a _bag_ constraint pertains to the information set as a whole and its packaging: spec version, text encoding, checksum algorithms, archive formats, etc. Second, a _tag_ constraint pertains to metadata fields contained in tag files: which are mandatory (required), what values are allowed, etc. Third, a _file_ constraint pertains to payload (or opaque tag) files: allowed file formats, sizes, etc.

#### Constraint Sets and Compatibility ####
It is important to recognize that different constraints can pertain to the same fields, etc - and for this reason they are only imposed (atomically) as sets. If one constraint from a set is incompatible with the existing context configuration, the entire set fails to form a valid context. Compatibility rules vary by constraint type, but a few general patterns or principles follow. _Orthogonality_: if constraints relate to different fields, types, concerns, etc then they are considered compatible. _Refinement_: if one constraint _narrows_ an existing constraint, it is considered compatible.

### Templates ###
By contrast, _templates_ are used to create bag values of various sorts. For example, a producer may wish to use standardized values for 'Source-Organization' and 'Organization-Address' in all bags they send. Rather than retyping or copy-pasting, a template could be used to automatically insert fixed strings. Templates could also contain variable data: consider a convention that named bag files with a date suffix: 'archives-{date}' might be a template for these names. This is a trivial example of a _generator_ - a parameterized method of producing variable content. Unlike constraints, non-orthogonal template values are always considered to be in conflict, resulting in an invalid _context_.

### Jobs ###
Jobs are comprehensive descriptions consisting of refernces to files forming a _context_, and optional source specification(s) (from a filesystem tree or an object store), and delivery instructions, which include a destination for created bags (as with sources, filesystems or object stores), and other instructions (e.g. delivery email notifictions, etc).